Notes: # represent headings
## represents the body
The Numpy (Numeric Python) package helps us manipulate large arrays and matrices of  numeric data.
 We may import this using import numpy in the beginning of our python code.

Numpy Arrays are similar to lists, but with one difference that their elements must be same
import numpy
a = numpy.array([1,2,3,4,5])
print a[1]

# In the above code numpy.array is used to convert the list to numpy array
Similarly We can also pass the same argument, to convert these integers into float

import numpy
a = numpy.array([1,2,3,4,5],float)
print a[1]


Task

You are give space separated list of numbers.
You need to print a reversed NumPy Array with the element type float.


Sample input 
1 2 3 4 -8 -10


# Shape & Reshape

The Shape tools gives a tuple of array dimensions & can be used to change the dimensions of the Array.

(a) Use shape to get the dimension of an array

a = numpy.array([1,2,3,4,5])
a.shape
output: (6,)

my_2d_array = numpy.array([[1,2],[3,4],[5,6]])
my_2d_array.shape
output : (3,2) Points: 541.00 Rank: 5202



(b) Use Shape to change the dimension of numpy array

change_array = numpy.array([1,2,3,4,5,6])
change_array.shape = (3,2)
output: [[1,2],[3,4],[5,6]]


# Reshape

The reshape tool gives a new shape to an array without changing it's data. It's creates a new array and doesn't modify the original array itself.

a = numpy.array([1,2,3,4,5,6])

print numpy.reshape(a,(3,2))
output: [[1,2],[3,4],[5,6]]


Task

You are given a space separated list of nine integers. Your task is to convert this list into a 3X3 NumPy array.
1 2 3 4 5 6 7 8 9


# Transpose & Flatten

## Transpose : We may get the transposition of an array using numpy.transpose. It does not affect the original array & creates a new array.

Example :
 a = numpy.array([[1,2,3], [4,5,6]])

output: [[1,4],[2,5],[3,6]]

## Flatten : The tool flatten creates a copy of the input array flattened to one dimension. 
 a = numpy.array([[1,2,3], [4,5,6]])
print a.flatten()

output : [1,2,3,4,5,6]

Task

You are given NxM elemenets with space separated elements. you need to print transpose and flatten results. first line of input has N and M. rest N columns each has M elements.
 2 2
 1 2
 3 4


# Concatenate 

Two or More numpy arrays can be concatenated using concatenate function.
numpy_array_1 = numpy.array([1, 2, 3])
numpy_array_2 = numpy.array([4, 5, 6])
numpy_array_3 = numpy.array([7, 8, 9])


print numpy.concatenate((numpy_array_1, numpy_array_2, numpy_array_3))
If an array has more than one dimension, it is possible to specify the axis along which multiple arrays are concatenated. By default, it is along the first dimension.

array_1 = numpy.array([1,2,3],[0,0,0])
array_2 = numpy.array([0,0,0],[7,8,9])

print (numpy.concatenate((array_1,array_2), axis = 1))


# Zeros and Ones

The zeros tool returns a new array with a given shape and type filled with 0's.
Default type is float

print numpy.zeros((1,2))
output : [[ 0.  0.]]

Converting Float type to int
print numpy.zeros((1,2) dtype = numpy.int)
The ones tool returns a new array with a given shape and type filled with 1's.
Default type is float
print numpy.ones((1,2) dtype = numpy.int)


Remember dimension is a tuple 

# Eye and Identity

identity : The identity tool returns an identity array. 
An identity array is a square matrix with all the main diagonal elements as 1 and the rest as 0. 
The default type of elements is float.
print numpy.identity(3)
output :
[[ 1.  0.  0.]
 [ 0.  1.  0.]
 [ 0.  0.  1.]]
 
Eye:
The eye tool returns a 2-D array with 1's as the diagonal and 0's elsewhere. 
The diagonal can be main, upper or lower depending on the optional parameter . 
A positive k is for the upper diagonal, a negative k is for the lower, and
a 0 k  (default) is for the main diagonal.

print numpy.eye(8, 7, k = 1) 
#Output
[[ 0.  1.  0.  0.  0.  0.  0.]
 [ 0.  0.  1.  0.  0.  0.  0.]
 [ 0.  0.  0.  1.  0.  0.  0.]
 [ 0.  0.  0.  0.  1.  0.  0.]
 [ 0.  0.  0.  0.  0.  1.  0.]
 [ 0.  0.  0.  0.  0.  0.  1.]
 [ 0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.]]

# Array Mathematics 

Basic mathematical functions operate element-wise on arrays. 
They are available both as operator overloads and as functions in the NumPy module.

import numpy

a = numpy.array([1,2,3,4], float)
b = numpy.array([5,6,7,8], float)

print a + b                     #[  6.   8.  10.  12.]
print numpy.add(a, b)           #[  6.   8.  10.  12.]

print a - b                     #[-4. -4. -4. -4.]
print numpy.subtract(a, b)      #[-4. -4. -4. -4.]

print a * b                     #[  5.  12.  21.  32.]
print numpy.multiply(a, b)      #[  5.  12.  21.  32.]

print a / b                     #[ 0.2         0.33333333  0.42857143  0.5       ]
print numpy.divide(a, b)        #[ 0.2         0.33333333  0.42857143  0.5       ]

# use // for integer division in python 3 

print a % b                     #[ 1.  2.  3.  4.]
print numpy.mod(a, b)           #[ 1.  2.  3.  4.]

print a**b                      #[  1.00000000e+00   6.40000000e+01   2.18700000e+03   6.55360000e+04]
print numpy.power(a, b)         #[  1.00000000e+00   6.40000000e+01   2.18700000e+03   6.55360000e+04]

# floor ceil and rint

floor: The tool floor returns the floor of the input element-wise. 
import numpy

my_array = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])
print numpy.floor(my_array)         #[ 1.  2.  3.  4.  5.  6.  7.  8.  9.]

ceil: The tool ceil returns the ceiling of the input element-wise. 
import numpy

my_array = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])
print numpy.ceil(my_array)          #[  2.   3.   4.   5.   6.   7.   8.   9.  10.]

rint: The rint tool rounds to the nearest integer of input element-wise.
import numpy

my_array = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])
print numpy.rint(my_array)          #[  1.   2.   3.   4.   6.   7.   8.   9.  10.]
